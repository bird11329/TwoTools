# configure
# Configure the compilation procedure
# Uses many codes from ROOT
# Note: comments lead the code: comment of a line of code is placed just before
#       the code.
# Author: wangyp (wangyp@pmo.ac.cn)
# Version: 1.0.0

#!/bin/bash

# Help message printer
print_help()
{
  cat << EOF
Usage: ./configure [options]
Configure the SelectionTool and/or OperationTool and get ready to install.

Mandatory arguments to long options are mandatory for short options too.
  -D<Flag>[=<value>]           Specify a flag for the compilation
                               (See below "Supported flags" for all flags).
  -o, --operation              Configure & install OperationTool as well
      --prefix=<PATH>          Folder in which to install the tool(s)
      --command=<COMMAND>      Specify compiling tools. <COMMAND> can either be
                               make (default), or be scons.
  -s, --scons                  Use "scons" rather than "make" to compile
  -h, --help                   Display this help and exit
  -c, --clean                  Clear all (temporary) files from configure

Supported flags in "-D":
  The prerequisites of either tool are:
    boost_program_options      A boost library that parses terminal arguments
    mysqlclient                Database supporter
  So they must be accessible if one wants to install the tool(s). Although this
  script tries to locate them automatically, it may fails, in which time one
  needs to specify their paths manually using flags:

      BOOST_LIB_PATH          Absolute path of the program options library
      MYSQL_LIB_PATH          Absolute path of the mysql-concerned library
      INCLUDE_PATH            (Absolute) path of headers

  If one's libraries have different names from here (the default name), they
  shall also be specified using:

      BOOST_LIB_NAME          Name of that library (boost_program_options)
      MYSQL_LIB_NAME          Name of the library (boost_program_options)

  Example:
   1 One has a /path1/path2/path3/libboost_program_options.so, it shall be
     specified by
       -DBOOST_LIB_PATH=/path1/path2/path3
   2 One has a /path1/path2/path3/libboost_program_options-mt.so, it shall be
     specified by
       -DBOOST_LIB_PATH=/path1/path2/path3 -DBOOST_LIB_NAME=boost_program_options-mt

  There are at most 4 flags provided, for there are only four different types
  of flags. But in case of repeated ones, the last will be taken.

Notes:
  1. Try running this script without any "-D" until it has trouble locating
     prerequisites
  2. If "--prefix" is provided, note the permissions
  3. The option "-c", "--clean" removes not only the file(s) generated by this
     script, but also the compiled files (and ".o" objects), because SConstruct
     and/or Makefile will also be removed if any. So it will be uninstalled
     before the file(s) are removed.

Exit status:
 0  if OK
 1  if minor problems (e.g. cannot access command-line argument)
 2  if serious trouble (e.g. missing prerequisites)
EOF
}

# Environment parameters
# Names of libraries
BOOST_LIB_NAME=
MYSQL_LIB_NAME=
# Paths of libraries
BOOST_LIB_PATH=
MYSQL_LIB_PATH=
# Installation folder (where executive binary file will be stored)
prefix=
# Command of the compiling tool. Either "scons" or "make", or it'll fail
# (value of this variant is just the compiling command).
compiling_tool=
# if with_operation is not 0, this script handles OperationTool
with_operation=0
# Current folder, where SConstruct or Makefile will be stored
current_folder=`pwd`

# Generate the log file, and record the time.
echo "$*" > "${current_folder}/config.status"
if [ $? -ne 0 ];then
  echo -e "\033[31;1mError!!! Can't create log in the current folder!\e[0m"
  echo -e "\e[90mMaybe because permission denied.\033[0m"
  exit 2
fi
logfile="${current_folder}/config.log"
echo >> $logfile
echo "Configuration of tool(s) starts on `date`." >> $logfile

# Log message printer (to the terminal) and saver (into $logfile)
# Arguments required, but no constraint on how many them.
errormsg()
{
  # Copied and modified from configure in ROOT
  # Write a simple message to std out
  if [ $# -lt 1 ];then
    return
  fi
  if [ "x$1" == "x-n" ];then
     shift
     echo -n "$*" >> $logfile
     echo -en "\e[31m$*\e[0m"
  else
     echo "$*" >> $logfile
     echo -e "\e[31m$*\e[0m"
  fi
}

# Log message printer (to the terminal) and saver (into $logfile)
# Arguments required, but no constraint on how many them.
# (Largely similar to 'errormsg' above)
logmsg()
{
  # Copied and modified from configure in ROOT
  # Write a simple message to std out
  if [ $# -lt 1 ];then
    echo "logmsg: Too few arguments"
    exit 1
  fi
  if [ "x$1" == "x-n" ];then
     shift
     echo -n "$*" | tee -a $logfile
  else
     echo "$*" | tee -a $logfile
  fi
}

# Progress printer
# Need 1 argument:
#   1. Name of component to check
checking_msg()
{
  # Copied and modified from configure in ROOT
  # Write a simple "checking" message to std out.
  if [ $# -lt 1 ];then
      errormsg "checking_msg: Too few arguments"
      exit 1
  fi
  logmsg "Checking for $1"
}

# Parse the compiling tool
# Need 2 arguments:
#   1. Message on the tool
#   2. Command of the tool
check_compiling_tool()
{
  if [ $# -ne 2 ];then
    errormsg 'check_compiling_tool: not 2 arguments'
    exit 1
  fi

  target=$2
  if [ "X${compiling_tool}X" == 'XX' ];then
    echo $1
  elif [ "$compiling_tool" != $target ];then
    echo "Repeated compiling option received. Updating with $target"
  else
    echo "Repeated compiling option received."
  fi
}

# Clear all file(s) generated by this script or by Makefile or SConstruct
# Called when "./configure -c" or "./configure --clean"
# No argument is necessary
clean_all()
{
  logmsg "Clear all files generated by configure on `date`..."
  declare -i N_deleted_files=0
  for file_to_delete in test_{selec,opera}tion_tool.cpp test_{S,O}T {S,O}T.log; do
    if [ -f "${file_to_delete}" ];then
      logmsg "Erasing ${file_to_delete}..."
      rm -v ${file_to_delete}
      N_deleted_files+=1
    fi
  done
  echo -e "SConstruct scons -cQ\nMakefile make clean" | while read file_to_delete commands; do
    if [ -f ${file_to_delete} ];then
      logmsg "Uninstalling..."
      $commands
      logmsg "Clearing ${file_to_delete}..."
      if [ `grep prefix\ =\  ${file_to_delete} | wc -l` -ne 0 ];then
        echo -e "\t\e[90mHint: installation prefix: `grep -e "prefix[ ]*=[ ]* " ${file_to_delete} | sed 's/prefix//; s/=//; s/  //g'`\e[0m"
      fi
      rm -f ${file_to_delete}
      N_deleted_files+=1
    fi
  done
  N_keys=`ls ${HOME}/.*.key 2>/dev/null | wc -l`
  if [ $N_keys -gt 1 ];then
    wanted=`ls -t1 ${HOME}/.*.key | head -1`
    mv $wanted ${wanted}_selected &&
    rm ${HOME}/.*.key &&
    mv ${wanted}_selected $wanted
    N_deleted_files+=$(($N_keys - 1))
    logmsg "$(($N_keys - 1)) obsolete keys removed."
  fi
  if [ $N_deleted_files -eq 0 ];then
    logmsg "No files erased."
  elif [ $N_deleted_files -gt 1 ];then
    logmsg "$N_deleted_files files erased."
  else
    logmsg "1 file erased."
  fi
}

# Parse the terminal argument(s) if any
argument=$1
while [ "X${argument}X" != 'XX' ]; do
  if [ "${argument:0:2}" == '-D' ];then
    # This is a flag passed from terminal
    # Protocol: -D<flag name>=<flag value>
    one_flag=${argument:2:14}
    case "${one_flag}" in
    'BOOST_LIB_NAME' | 'MYSQL_LIB_NAME' | 'BOOST_LIB_PATH' | 'MYSQL_LIB_PATH')
      eval \$$one_flag=${argument:16}
    ;;
    *)
      errormsg "Error! Unrecognized flag |${argument:2}|!"
      exit 1
    ;;
    esac
  elif [ "${argument:0:2}" == '--' ];then
    # An option in an elongated format
    # Protocol: --<option>[=<value>]
    the_hint=${argument:2}
    if [ "${the_hint:0:9}" == 'operation' ];then
      with_operation=1
      echo "OperationTool enabled."
    elif [ "${the_hint:0:6}" == 'prefix' ];then
      prefix=${the_hint:7}
    elif [ "${the_hint:0:7}" == 'command' ];then
      tmp_tool=`echo ${the_hint:7} | tr '[A-Z]' '[a-z]'`
      case "${tmp_tool}" in
      'scons')
        check_compiling_tool 'Use scons to compile' 'scons'
        compiling_tool='scons'
      ;;
      'make')
        check_compiling_tool 'Unnecessary option "--command". Default behavior.' 'make'
        compiling_tool='make'
      ;;
      *)
        errormsg "Error! Unrecognized compiling tool! Either scons or make is accepted."
        exit 1
      ;;
      esac
    elif [ "${the_hint:0:4}" == 'help' ];then
      print_help
      exit 0
    elif [ "${the_hint:0:5}" == 'scons' ];then
      check_compiling_tool 'Use scons to compile' 'scons'
      compiling_tool='scons'
    elif [ "${the_hint:0:5}" == 'clean' ];then
      clean_all
      exit 0
    else
      errormsg "Error! Unrecognized long option |${argument:2}|!"
      exit 1
    fi
  elif [ "${argument:0:1}" == '-' ];then
    # A short option
    # Protocol: -<option>
    case "${argument:1:1}" in
    'h')
      print_help
      exit 0
    ;;
    'o')
      with_operation=1
      echo "OperationTool enabled."
    ;;
    's')
      check_compiling_tool 'Use scons to compile' 'scons'
      compiling_tool='scons'
    ;;
    'c')
      clean_all
      exit 0
    ;;
    *)
      errormsg "Error! Unrecognized long option |${argument:2}|!"
      exit 1
    ;;
    esac
  else
    errormsg "Error! Unrecognized flag |${argument:2}|!"
    exit 1
  fi
  shift
  argument=$1
done
unset argument

# For compiling tool
if [ "X${compiling_tool}X" == 'XX' ];then
  compiling_tool='make'
fi
# Testing if the compiling_tool is ready
$compiling_tool --version >/dev/null 2>&1
if [ $? -ne 0 ];then
  errormsg "Compiling tool ${compiling_tool} is not ready..."
  exit 2
fi
#echo "with_operation = |${with_operation}|"
#echo "compiling_tool = |${compiling_tool}|"

# Check if a file exists
# Need an argument:
#   1. Name of file to check
check_file()
{
  # Check if the source file exists.
  a_file=$1
  if [ "X${a_file}X" == 'XX' ];then
    return
  fi

  message=''
  if [ ! -f "$a_file" ];then
    message="Missing component \"${a_file}\""
  elif [ `du -b "$a_file" | awk '{print $1}'` -eq 0 ];then
    message="Invalid component \"${a_file}\""
  elif [ ! -r "$a_file" ];then
    message="Irreadable component \"${a_file}\""
  fi
  if [ "X${message}X" != 'XX' ];then
    errormsg "Error!!! ${message}!"
    exit 2
  fi
}

check_file common_tools.cc
check_file common_tools.h
check_file main_selection.cpp
check_file selection_tool.cc
check_file selection_tool.h
check_file SelectionTool.help
if [ $with_operation -ne 0 ];then
  check_file main_operation.cpp
  check_file operation_tool.cc
  check_file operation_tool.h
  check_file OperationTool.help
fi
check_file configure
if [ ! -x configure ];then
  echo -e "\033[90mAdding permission of being executable to configure...\033[0m"
  chmod a+x -v configure
fi

# Check if a header exists
# Need one argument:
#   1. Union of headers to be checked
check_header()
{
  # Copied and modified from configure in ROOT

  # This function will try to locate a header [$1]

  # Assert that we got enough arguments
  if [ $# -lt 1 ];then
    echo "check_header: Too few arguments"
    return 1
  fi

  # Save arguments in logical names
  hdrs=$1
  hdrdirs="/usr/include /usr/local/include"
  if [ "X${INCLUDE_PATH}X" != 'XX' ];then
  for one_path in ${INCLUDE_PATH}; do
    if [ "${one_path:0:2}" == '-I' ]||[ "${one_path:0:2}" == '-I' ];then
    one_path="${one_path:2}"
    fi
    if [ -d $one_path ];then
    hdrdirs="${one_path} $hdrdirs"
    fi
  done
  fi

  # Write a message
  checking_msg $hdrs

  # Loop over the list of possible directories, and see if we can
  # find any of the library files as determind above.
  for j in ${hdrs} ; do
    logmsg "  Checking for $j"
    found_dir=no
    # if we found the file (it's readable by user), we set the
    # logical variables and are on our way, otherwise we continue
    for i in $hdrdirs; do
      logmsg " Checking in directory $i"
      if [ -r $i/$j ];then
        logmsg "  $i/$j is readable"
        found_dir=$i
        break 2
      fi
    done
    if [ "X${found_dir}X" == 'XX' ]||[ "x$found_dir" == "xno" ];then
      errormsg "Error! Can't find the header \"$j\"..."
      exit 2
    elif [ "X${CPPPATH}X" == 'XX' ];then
      CPPPATH="-I${found_dir}"
    else
      CPPPATH="${CPPPATH} -I${found_dir}"
    fi
  done

  unset hdrdirs
}

check_header 'mysql/mysql.h boost/program_options.hpp boost/algorithm/string.hpp'
if [ $with_operation -ne 0 ];then
  check_header 'boost/property_tree/ptree.hpp boost/property_tree/json_parser.hpp'
fi
unset INCLUDE_PATH

# Need 1 argument:
#   1. Name of library to be checked.
check_lib64()
{
  # Copied directly from configure in ROOT

  # This function will try to find out if a library [$1] contains 64 bit
  # or 32 bit code. Currently works only for linux and solaris.
  # The result of the check is stored in is_lib64, 1 if true,
  # 0 otherwise, which should be immediately copied, since the variable
  # will be overwritten at next invocation of this function.

  is_lib64=0
  ret=0

  # Assert that we got enough arguments
  if [ $# -ne 1 ];then
    echo "check_lib64: not 1 argument"
    return 1
  fi
  echo "check_lib64 $1"

  filearg=
  case $arch in
    *linux*)   filearg="-L" ;;
    *solaris*) ;;
    *)       echo "return 1"; return 1;;
  esac

  # Save arguments in logical names
  chklib64=$1
  logmsg "Checking if $chklib64 is a 64-bit library"
  if [ "x`basename $chklib64 .a`" != "x`basename $chklib64`" ]; then
    # we have an archive .a file
    if [ "x$arch" = "xlinux" ]; then
      logmsg " objdump -a $chklib64 | grep 'x86-64'"
      if objdump -a $chklib64 | grep 'x86-64' > /dev/null 2>& 1 ; then
        ret=1
      fi
    fi
    if [ "x$arch" = "xsolaris" ]; then
      chklib64file=`ar t $chklib64 | awk '{if (NR == 2) print $1}'`
      logmsg " ar x $chklib64 $chklib64file"
      ar x $chklib64 $chklib64file
      logmsg " file $filearg $chklib64file | grep '64-bit'"
      if file $filearg $chklib64file | grep '64-bit' > /dev/null 2>& 1 ; then
        ret=1
      fi
      rm -f $chklib64file
    fi
  else
    if file $filearg $chklib64 | grep 'ASCII' > /dev/null 2>& 1 ; then
      check_link $chklib64
      ret=$link_result
    else
      logmsg " file $filearg $chklib64 | grep '64-bit'"
      if file $filearg $chklib64 | grep '64-bit' > /dev/null 2>& 1 ; then
        ret=1
      fi
    fi
  fi
  logmsg " result: $ret"
  if [ $ret -eq 1 ];then
    is_lib64=1
    logmsg " is a 64bit library"
  fi
}

# Try to guess the architecture of the host system
# Copied directly for configure in ROOT.
arch=`uname -s | tr '[A-Z]' '[a-z]'`
chip=`uname -m | tr '[A-Z]' '[a-z]'`
rele=`uname -r`
logmsg "arch=$arch"
logmsg "chip=$chip"
logmsg "rele=$rele"
case "$arch:$chip:$rele" in
    aix*)                  arch=aix5            ;;
    osf1*:alpha:*)         arch=alphacxx6       ;;
    freebsd*:*:[789]*)     arch=freebsd7        ;;
    freebsd*:*:6*)         arch=freebsd5        ;;
    freebsd*:*:5*)         arch=freebsd5        ;;
    freebsd*:*:4*)         arch=freebsd4        ;;
    freebsd*:*:*)          arch=freebsd         ;;
    hp-ux:ia64:*)          arch=hpuxia64acc     ;;
    hp-ux:*:*)             arch=hpuxacc         ;;
    hurd*:*:*)             arch=hurddeb         ;;
    linux:ia64:*)          arch=linuxia64gcc    ;;
    linux:x86_64:*)        arch=linuxx8664gcc   ;;
    linux:alpha:*)         arch=linuxalphagcc   ;;
    linux:arm*:*)          arch=linuxarm        ;;
    linux:hppa*:*)         arch=linux           ;;
    linux:mips:*)          arch=linuxmips       ;;
    linux:sparc*:*)        arch=linux           ;;
    linux:parisc*:*)       arch=linuxhppa       ;;
    linux:ppc64*:*)        arch=linuxppc64gcc   ;;
    linux:ppc*:*)          arch=linuxppcgcc     ;;
    linux:i*86:*)          arch=linux           ;;
    linux:s39*:*)          arch=linux           ;;
    openbsd*:*:*)          arch=openbsd         ;;
    lynx:*:*)              arch=lynxos          ;;
    darwin:power*:*)       arch=macosx          ;;
    darwin:*86*:*)         arch=macosx          ;;
    irix*:sgi*:*)          arch=sgicc           ;;
    sunos:sun*:6*)         arch=solarisCC5      ;;
    sunos:sun*:5*)         arch=solarisCC5      ;;
    sunos:sun*:4*)         arch=solaris         ;;
    sunos:i86pc:5*)        arch=solarisCC5      ;;
    cygwin_*:*86:*)        arch=win32           ;;
    cygwin_*:pentium:*)    arch=win32           ;;
    cygwin_*:ia64)         arch=win32           ;;
    mingw32_*:*86:*)       arch=win32           ;;
    *)
        echo "Attempts at guessing your architecture failed."
        echo "(triplet is $arch:$chip:$rele)"
        echo "Please specify the architecture as the first argument."
        echo "Do '$0 --help' for a list of available architectures."
        echo "Or file a bug at https://savannah.cern.ch/projects/savroot/"
        echo "including the full config.log and a dump of"
        echo "  touch dummy_file.c; gcc -E -dM dummy_file.c"
        exit 1
        ;;
esac
if [ "$arch" = "macosx" ]; then
   if [ `sw_vers | sed -n 's/ProductVersion://p' | cut -d . -f 2` -ge 5 ]; then
      if `sysctl machdep.cpu.extfeatures | grep "64" > /dev/null  2>&1` ; then
         arch=macosx64
      fi
   fi
fi
logmsg "Final: |${arch}|"
# End of copy

# Copied and modified from configure in ROOT
case $arch in
sgicc)
   logmsg "Will check 32bit libraries"
   checklib32="yes" ;;
linuxppc64*|sgicc64)
   logmsg "Will ONLY check 64bit libraries"
   checkonlylib64="yes" ;;
linuxx8664k1om*)
   logmsg "Will not check 64bit libraries"
   checklinux64="no"
   checklib64="no"
   enable_cintex="no"
   enable_reflex="no"
   enable_genvector="no"
   enable_tmva="no"
   ;;
linuxx8664*)
   logmsg "Will check 64bit libraries"
   checklinux64="yes"
   checklib64="yes" ;;
hpuxia64acc)
   logmsg "Will check HP/UX 64bit libraries"
   checkhpux64="yes" ;;
solaris64CC5)
   logmsg "Will check Solaris 64bit libraries"
   checksolaris64="yes"
   checklib64="yes" ;;
macosx*)
   logmsg "Will check for compatible libraries"
   checklibcompat="yes"
   logmsg "Will check for compatible C++ run-time libraries"
   checklibcxxcompat="yes"
   if test "x$macosxvers" = "x"; then
      # get most recent SDK version
      macosxminor=`sw_vers | sed -n 's/ProductVersion://p' | cut -d . -f 2`
      macosxvers=10.$macosxminor
   fi
   # make available to conftest.mk scripts
   export MACOSXVERS=$macosxvers
   ;;
ios*)
   logmsg "Will check iOS SDK libraries"
   message "Checking for iOS SDK"
   if test "x$iosvers" = "x"; then
      # get most recent SDK version
      iosvers=`xcodebuild -showsdks | sed -n '/iphoneos/s/.*iOS //p' | sed 's/ .*//'|awk 'END{print}'`
   fi
   if [ `echo $iosvers | cut -d . -f 1` -ge 7 ]; then
      ios7=yes
   fi
   xcodepath=`/usr/bin/xcode-select -print-path`
   if test "x$arch" = "xios"; then
      iossdk=$xcodepath/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS$iosvers.sdk
   else
      iossdk=$xcodepath/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator$iosvers.sdk
   fi
   result "$iossdk"
   if [ ! -d $iossdk ]; then
       result "`basename $0`: no iOS SDK found at $iossdk"
       result "Run "xcode-select" to update the developer directory path"
       result "or make sure the desired SDK version is installed"
       exit 1
   fi
   # make available to conftest.mk scripts
   export IOSSDK=$iossdk
   export IOSVERS=$iosvers
   enable_cintex="no"
   enable_reflex="no"
   enable_genvector="no"
   enable_tmva="no"
   ;;
win32)
   logmsg "Will use by default builtin versions of libraries on Win32"
   enable_builtin_freetype="yes"
   enable_builtin_ftgl="yes"
   enable_builtin_glew="yes"
   enable_builtin_pcre="yes"
   enable_builtin_zlib="yes"
   enable_builtin_lzma="yes"
   top_builddir=`cygpath -u $top_builddir`
   top_srcdir=`cygpath -u $top_srcdir`
   ;;
esac

# Need 1 argument:
#   1. Name of library to be checked.
check_libcompat()
{
  # Copied and modified from configure in ROOT

  # This function will try to find out if a library [$1] contains
  # compatible 64 bit or 32 bit code matching the selected architecture.
  # Currently only MacOS X supports universal libs.
  # The result of the check is stored in is_libcompat, 1 if true,
  # 0 otherwise, which should be immediately copied, since the variable
  # will be overwritten at next invocation of this function.

  is_libcompat=0
  is_libnotcompat=0
  ret=0

  # Assert that we got enough arguments
  if [ $# -ne 1 ];then
    echo "check_libcompat: not 1 argument"
    return 1
  fi

  # Save arguments in logical names
  chklibcompat=$1
  logmsg "Checking if $chklibcompat contains compatible code"

  case $arch in
  macosx)
    logmsg " lipo -info $chklibcompat | grep ' i386'"
    if lipo -info $chklibcompat | grep ' i386' > /dev/null 2>& 1 ; then
      ret=1
    fi
    ;;
  macosx64)
    logmsg " lipo -info $chklibcompat | grep ' x86_64'"
    if lipo -info $chklibcompat | grep ' x86_64' > /dev/null 2>& 1 ; then
      ret=1
    fi
    ;;
  esac

  logmsg " result: $ret"
  if [ $ret -eq 1 ];then
    is_libcompat=1
    logmsg " is a compatible library"
  else
    is_libcompat=0
    logmsg " is a not-compatible library"
  fi
}

# Need 1 argument:
#   1. Name of library to be checked.
check_libcxxcompat()
{
  # Copied directly from configure in ROOT

  # This function will try to find out if a library [$1] is linked
  # against a compatible C++ run-time library (either libstdc++ or libc++).
  # Currently only MacOS X and Linux support libc++ and libstdc++.
  # The result of the check is stored in is_libcxxcompat, 1 if true,
  # 0 otherwise, which should be immediately copied, since the variable
  # will be overwritten at next invocation of this function.
  # To avoid this check, in case std types are not used in the public
  # API of the library, set skipchecklibcxxcompat="yes".

  is_libcxxcompat=1
  ret=0

  # Assert that we got enough arguments
  if [ $# -ne 1 ];then
    echo "check_libcxxcompat: not 1 argument"
    return 1
  fi

  # Can we skip the check in case library has no std C++ in public API
  if [ "x$skipchecklibcxxcompat" = "xyes" ];then
    skipchecklibcxxcompat=""
    logmsg "check_libcxxcompat: skipping check for $1"
    return
  fi

  # Save arguments in logical names
  chklibcxxcompat=$1
  logmsg "Checking if $chklibcxxcompat is linked against compatible C++ run-time"

  if [ "x$enable_libcxx" = "xyes" ];then
    case $arch in
    macosx*)
      logmsg " otool -L $chklibcxxcompat | grep libstdc++"
      if otool -L $chklibcxxcompat | grep 'libstdc++' > /dev/null 2>& 1 ; then
        ret=1
      fi
      ;;
    linux*)
      logmsg " ldd $chklibcxxcompat | grep libstdc++"
      if ldd $chklibcxxcompat | grep 'libstdc++' > /dev/null 2>& 1 ; then
        ret=1
      fi
      ;;
    esac
  else
    case $arch in
    macosx*)
      logmsg " otool -L $chklibcxxcompat | grep libc++"
      if otool -L $chklibcxxcompat | grep 'libc++' > /dev/null 2>& 1 ; then
        ret=1
      fi
      ;;
    linux*)
      logmsg " ldd $chklibcxxcompat | grep libc++"
      if ldd $chklibcxxcompat | grep 'libc++' > /dev/null 2>& 1 ; then
        ret=1
      fi
      ;;
    esac
  fi

  logmsg " result: $ret"
  if [ $ret -eq 1 ];then
    is_libcxxcompat=0
    logmsg " is linked against not-compatible C++ run-time library"
  else
    is_libcxxcompat=1
    logmsg " is linked against compatible C++ run-time library"
  fi
}

# Need 1 argument:
#   1. Name of library to be checked.
check_library()
{
  # Copied and modified from configure in ROOT

  # This function will try to locate a library [$2] in the specific
  # directory [$3] or in a default path [$*]. The result of the search
  # is stored in variables indicated by $1

  # Assert that we got enough arguments
  if [ $# -ne 1 ];then
    echo "check_library: not 1 argument ($#)..."
    return 1
  fi

  para_core=$1
  lib_name=${para_core}_NAME
  lib_path=${para_core}_PATH
  unset para_core

  eval lib=\$$lib_name
# echo "lib = |${lib}|, lib_name = |${lib_name}|"
  # Write a message
  checking_msg $lib

  found_lib=no
  found_dir=no
  found_ext=

  libs=""
  for i in $lib ; do
    for ext in .a .lib .so .sl .dylib .dll.a "" ; do
      libs="$libs $i$ext"
    done
  done

  eval new_path=\$$lib_path
  tmp_libdirs="${libdirs}"
  if [ "X${new_path}X" != 'XX' ];then
    for one_path in ${new_path}; do
      if [ "X${one_path}X" == 'XX' ]||[ "$one_path" == ' ' ];then
        continue
      fi
      if [ ${one_path:0:2} == '-L' ]||[ ${one_path:0:2} == '-l' ];then
        one_path=${one_path:2}
      fi
      if [ -d $one_path ];then
        tmp_libdirs="${libdirs} $one_path"
      fi
    done
  fi

  logmsg "libraries to check for: $libs"
  # Loop over the list of possible directories, and see if we can
  # find any of the library files as determind above.
  for i in $tmp_libdirs; do
    logmsg " Checking in directories $i for $libs"
    for l in $i ; do
      l=`echo $l | sed 's,^//,/,'`
      for j in ${libs} ; do
        real_lib_name="lib$j"
        logmsg "  Checking for library $real_lib_name in directory $l"
        # if we found the file (it's readable by user), we set the
        # logical variables and are on our way, otherwise we continue
        possibly_found=0
        n="${l}/${real_lib_name}"
        if [ -f $n ];then
          possibly_found=1
        else
          folder=`dirname $n`
          filename=`basename $n`
          case "`ls $folder/*${filename%%.*}*.${filename##*.} 2>/dev/null | wc -l`" in
          '1')
            possibly_found=2
            real_lib_name=`ls $folder/*${filename%%.*}*.${filename##*.} | xargs basename`
          ;;
          '0')
            :
          ;;
          *)
            echo "Multiple libraries located (`ls $folder/*${filename%%.*}*.${filename##*.} | wc -l`) for $filename"
          ;;
          esac
        fi
        if [ $possibly_found -ne 0 ];then
          logmsg "   Found file $n"
          if [ "x$checklib64" == "xyes" ];then
            check_lib64 $n
            if [ $is_lib64 -eq 1 ];then
              if [ "X${new_path}X" != 'XX' ];then
                eval \$$lib_path=$l
              fi
              if [ $possibly_found -eq 2 ];then
                eval \$$lib_name=$real_lib_name
              fi
              break 4
            fi
          else
            if [ "x$checklibcompat" == "xyes" ];then
              is_libcompat=0
              check_libcompat $n
              if [ $is_libcompat -eq 0 ];then
                break 4
              fi
            fi
            if [ "x$checklibcxxcompat" == "xyes" ];then
              is_libcxxcompat=0
              check_libcxxcompat $n
              if [ $is_libcxxcompat -eq 0 ];then
                break 4
              fi
            fi
            if [ "x$arch" == "xlinux" ];then
              check_lib64 $n
            else
              is_lib64=0
            fi
            if [ $is_lib64 -eq 1 ];then
              echo "\$$lib_path found but illegal..."
              echo "\$$lib_name found but illegal..."
            else
              if [ "X${new_path}X" != 'XX' ];then
                eval \$$lib_path=$l
              fi
              if [ $possibly_found -eq 2 ];then
                eval \$$lib_name=$real_lib_name
              fi
              break 4
            fi
          fi
        else
          logmsg "  $real_lib_name not found in $l"
        fi
        unset real_lib_name
      done
    done
  done
  unset tmp_libdirs lib flib maclib
  unset lib_path lib_name
}

# Trying to locate the libraries wanted
# All possible paths (not ensured)
tmp_libdirs='/lib /lib64 /usr/lib /usr/lib64 /usr/local/lib /usr/local/lib64'
# All possible paths (ensured)
libdirs=''
echo "checklinux64 = |${checklinux64}|"
for i in ${tmp_libdirs}; do
  # Copied and modified from configure in ROOT

  # look first in the lib32 directories
  if [ "x$checklib32" == "xyes" ];then
    i32=`echo $i | sed -e 's|lib$|lib32|;s|lib/|lib32/|'`
    i="$i32"
  fi
  # look first in the lib64 directories
  if [ "x$checklinux64" == "xyes" ];then
    i64=`echo $i | sed -e 's|lib$|lib64|;s|lib/|lib64/|'`
    i="$i64"
  fi
  # look only in the lib64 directories
  if [ "x$checkonlylib64" == "xyes" ];then
    i64=`echo $i | sed -e 's|lib$|lib64|;s|lib/|lib64/|'`
    i="$i64"
  fi
  # look only in the hpux64 directories
  if [ "x$checkhpux64" == "xyes" ];then
    i64=`echo $i | sed 's|\(lib\)|\1/hpux64|'`
    i="$i64"
  fi
  # look first in the amd64 directories
  if [ "x$checksolaris64" == "xyes" ];then
    i64=`echo $i | sed 's|\(lib\)|\1/amd64|'`
    i="$i64 $i"
  fi
  if [ -d "$i" ];then
    libdirs="${libdirs} $i"
  fi
  # End of copy from ROOT
done
unset tmp_libdirs
libdirs=${libdirs:1}
echo "libdirs = |${libdirs}|"
libdirs=`echo $libdirs | sed 's/:/\n/g' | sort | uniq`
libdirs=`echo ${libdirs//\ /:} | sed 's/ /:/g'`
echo "libdirs = |${libdirs}|"
libdirs="${libdirs//:/ }"
echo "libdirs = |${libdirs}|"

# Check and complement the name of two additional libraries
if [ "X${BOOST_LIB_NAME}X" == 'XX' ];then
  BOOST_LIB_NAME=boost_program_options
fi
if [ "X${MYSQL_LIB_NAME}X" == 'XX' ];then
  MYSQL_LIB_NAME=mysqlclient
fi

check_library BOOST_LIB
check_library MYSQL_LIB
unset libdirs
logmsg "All libraries checked."

if [ "X${prefix}X" == 'XX' ];then
  prefix=${current_folder}
fi
# Create installation prefix if it doesn't exist
if [ ! -d ${prefix} ]&&[ $need_to_install -eq 1 ];then
  logmsg "Target folder ${prefix} doesn't exist. Trying to create one..."
  mkdir -p -v $prefix
  if [ $? -ne 0 ];then
    errormsg "Error creating target folder ${target}..."
    exit 2
  fi
fi

# Check the installation path if it's not the current folder
# (Don't need to check current folder because it has been verified by logfile)
logmsg "Testing permissions of the target folder |${prefix}|"
> ${prefix}/non-exist 2>/dev/null
if [ $? -ne 0 ];then
  errormsg "Permission of prefix \"${prefix}\" denied..."
  exit 2
fi
rm -f ${prefix}/non-exist 2>/dev/null
logmsg "Permission acceptable."

# Generate "configuration.cc", a file for authentication (not done here)
cat > configuration.cc << EOF_CONFIG
#include "common_tools.h"
using namespace std;

string Configuration::ConfigurationFolder() const
{ return "`pwd`"; }

Configuration& Configuration::GetInstance()
{
  static Configuration instance;
  return instance;
}

EOF_CONFIG

# (Set later) If need_to_install is not 0, compilation tool need to install it
# Here "configuration.cc" is not finished, either
need_to_install=-1
if [ "X${prefix}X" == 'XX' ];then
  prefix="${current_folder}"
  need_to_install=0
  cat >> configuration.cc << EOF_CONFIG
string Configuration::InstallationFolder() const { return ""; }

EOF_CONFIG
else
  need_to_install=1
  cat >> configuration.cc << EOF_CONFIG
string Configuration::InstallationFolder() const
{ return "${prefix//\//\\\/}"; }

EOF_CONFIG
fi

# If with_operation is not 0, there is a need to install OperationTool
# configuration.cc is done after this
if [ $with_operation -eq 0 ];then
  # In case of only SelectionTool, configuration.cc looks simple
  cat >> configuration.cc << EOF_CONFIG
const char* Configuration::Authentication() const
{ return "";}

bool Configuration::Authenticating(const string& real_key) const
{ return true; }

Configuration::Configuration() {}

EOF_CONFIG
else
  # For OperationTool & SelectionTool, first generate a key file at $HOME
  # This is the name of the key
  key_name=".`cat /dev/urandom | tr -dc [:alnum:] | head -c10`.key"
  key_name="${HOME}/${key_name}"
  # And the content of the key
  key_value=`cat /dev/urandom | tr -dc [:graph:] | head -c100`
  # Generate the key
  echo "$key_value" > $key_name
  if [ $? -ne 0 ];then
    errormsg "Error generating authenticating key..."
    errormsg 'Authentication key failed (1)...'
    exit 2
  fi
  key_value="${key_value//\\/\\\\}"
# echo "key_name = |${key_name}|, key_value = |${key_value}|"
  key_value=`echo $key_value | sed 's/\"/\\\"/g'`
  # Complementing configuration.cc
  cat >> configuration.cc << EOF_CONFIG
const char* Configuration::Authentication() const
{ return "${key_name}"; }

Configuration::Configuration():
  expected_key("${key_value}")
{}

bool Configuration::Authenticating(const string& real_key) const
{ return expected_key == real_key; }

EOF_CONFIG
  if [ $? -ne 0 ];then
    errormsg "Error generating authenticating key..."
    errormsg 'Authentication key failed (2)...'
    exit 2
  fi
  unset key_name key_value
fi

g++ -c configuration.cc
feedback=$?
rm -f configuration.cc
if [ $feedback -ne 0 ];then
  echo -e "\033[31mError generating authenticating key...\033[0m"
  errormsg 'Authentication key failed (3)...'
  exit 2
else
  logmsg 'Authentication key generated.'
fi
unset feedback

# Testing compiling environment of SelectionTool
logmsg "Testing compiling environment..."
echo -e "\t\e[90m(This may takes a while...)\e[0m"
# Entering the installation prefix
cd $prefix
# Generate an sample code with the same requirements of headers and libraries
cat > test_selection_tool.cpp << EOF_ST
#include <boost/algorithm/string.hpp>
#include <boost/program_options.hpp>
#include <mysql/mysql.h>
int main() {}
EOF_ST
# Trying if there is an old result
# If can_t_delete is not 0, there is an old result that can't be removed
can_t_delete=0
if [ -f test_ST ];then
  logmsg "Warning... There is a test_OT in the folder..."
  rm -f test_OT
  if [ $? -ne 0 ];then
    logmsg "Trial compilation for SelectionTool skipped."
    can_t_delete=1
  fi
fi
# If can_t_delete is not 0, no use compiling for there has been one already
if [ $can_t_delete -eq 0 ];then
  with_error=0
  g++ ${CPPPATH} test_selection_tool.cpp ${BOOST_LIB_PATH} ${MYSQL_LIB_PATH} -l${BOOST_LIB_NAME} -l${MYSQL_LIB_NAME} -o test_ST 2>ST.log
  if [ ! -f test_ST ];then
    logmsg "Error compiling SelectionTool..."
    if [ `cat ST.log | wc -l` -ne 0 ];then
      cat ST.log | sed -n '/cannot/p;/No such/p'
    fi
    with_error=1
  fi
fi
rm -f test_selection_tool.cpp test_ST ST.log
# Trying OperationTool if required. The same case as SelectionTool
if [ $with_operation -ne 0 ];then
  cat > test_operation_tool.cpp << EOF_OT
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/program_options.hpp>
#include <mysql/mysql.h>
int main() {}
EOF_OT
  can_t_delete=0
  if [ -f test_OT ];then
    logmsg "Warning... There is a test_OT in the folder..."
    rm -f test_OT
    if [ $! -ne 0 ];then
      logmsg "Trial compilation for OperationTool skipped."
      can_t_delete=1
    fi
  fi
  if [ $can_t_delete -eq 0 ];then
    g++ ${CPPPATH} test_operation_tool.cpp ${BOOST_LIB_PATH} ${MYSQL_LIB_PATH} -l${BOOST_LIB_NAME} -l${MYSQL_LIB_NAME} -o test_OT 2>OT.log
    g++ ${CPPPATH} test_operation_tool.cpp ${BOOST_LIB_PATH} ${MYSQL_LIB_PATH} -l${BOOST_LIB_NAME} -l${MYSQL_LIB_NAME} -o test_OT 2>OT.log
    if [ ! -f test_OT ];then
      logmsg "Error compiling OperationTool..."
      [ `cat ST.log | wc -l` -ne 0 ] && cat ST.log | sed -n '/cannot/p;/No such/p'
      with_error=1
    fi
  fi
fi
unset can_t_delete
if [ $with_error -ne 0 ];then
  exit 2
fi
unset with_error
if [ $with_operation -ne 0 ];then
  rm -f test_operation_tool.cpp test_OT OT.log
fi
logmsg "Compilation try succeeded."

# Generate default option for the tools (where they can find info to connect)
cd $current_folder
cat > default.ini << EOF_SAMPLE_INI
server=dpnc.unige.ch
user=anonymous
passwd=testing
database=DAMPE_GENEVA
type=data_2a_tbl
port=3306
EOF_SAMPLE_INI

# Name of tools to be generated
the_tools='SelectionTool'
if [ $with_operation -ne 0 ];then
  the_tools="${the_tools} and OperationTool"
fi
#echo "compiling_tool = |${compiling_tool}|"

# Generating compilation instructions
if [ "$compiling_tool" == 'scons' ];then
  # In case of scons, it uses SConstruct
  echo "Generating SConstruct..."
  cat > SConstruct << EOF_SCONS
env = Environment()

env.Append(LIBS=['${MYSQL_LIB_NAME}'])
env.Append(LIBS=['${BOOST_LIB_NAME}'])
EOF_SCONS
  if [ $need_to_install -eq 1 ];then
    # Adding installation prefix
    echo "prefix = '${prefix}'" >> SConstruct
  fi
  cat >> SConstruct << EOF_SCONS
target1 = 'SelectionTool'
goal1 = env.Program(target1, ['main_selection.cpp', 'selection_tool.cc', 'common_tools.cc', 'configuration.o'])
EOF_SCONS
  # Insert int SConstruct for libraries and header options if any
  if [ "X${CPPPATH}X" != 'XX' ];then
    sed -i "4a env.Append(CPPPATH=['${CPPPATH}'])" SConstruct
  fi
  if [ "X${BOOST_LIB_PATH}X" != 'XX' ];then
    sed -i "2a env.Prepend(LIBPATH=['${BOOST_LIB_PATH}'])" SConstruct
  fi
  if [ "X${MYSQL_LIB_PATH}X" != 'XX' ];then
    sed -i "2a env.Prepend(LIBPATH=['${MYSQL_LIB_PATH}'])" SConstruct
  fi
  # Insert compilation rules for OperationTool
  if [ $with_operation -ne 0 ];then
    cat >> SConstruct << EOF_SCONS
target2 = 'OperationTool'
goal2 = env.Program(target2, ['main_operation.cpp', 'operation_tool.cc', 'common_tools.cc', 'configuration.o'])
EOF_SCONS
  fi
  if [ "${prefix}" != `pwd` ];then
    echo "Default(env.InstallAs(prefix+'/'+target1, goal1))" >> SConstruct
    if [ $with_operation -ne 0 ];then
      echo "Default(env.InstallAs(prefix+'/'+target2, goal2))" >> SConstruct
    fi
  fi
  logmsg 'Configuration done.'
  # This is the terminal guide
  cat << EOF_SCONS
  Next, please run in the current folder

    scons

  to compile and install ${the_tools}.
  And to undo the installation, one can run in the current folder
    scons -cQ
EOF_SCONS
elif [ "$compiling_tool" == 'make' ];then
  # In case of make, it uses Makefile
  echo "Generating Makefile..."
  echo '.PHONY: all' > Makefile
  if [ $with_operation -ne 0 ];then
    echo "all: OperationTool SelectionTool" >> Makefile
  else
    echo "all: SelectionTool" >> Makefile
  fi
  # Prepare libraries and header options for compilation
  CPPFLAGS=' '
  if [ "X${CPPPATH}X" != 'XX' ];then
    CPPFLAGS="${CPPFLAGS}${CPPPATH}"
  fi
  if [ "X${BOOST_LIB_PATH}X" != 'XX' ];then
    CPPFLAGS="${CPPFLAGS} -L${BOOST_LIB_PATH}"
  fi
  if [ "X${MYSQL_LIB_PATH}X" != 'XX' ];then
    CPPFLAGS="${CPPFLAGS} -l${MYSQL_LIB_PATH}"
  fi
  CPPFLAGS="${CPPPATH} -l${BOOST_LIB_NAME} -l${MYSQL_LIB_NAME}"
  echo "CPPFLAGS = ${CPPFLAGS}" >> Makefile
  # Continue editing Makefile
  cat >> Makefile << EOF_MAKE
common_tools.o: common_tools.cc
	gcc -c common_tools.cc

SelectionTool: main_selection.o selection_tool.o common_tools.o configuration.o
	gcc main_selection.o selection_tool.o common_tools.o configuration.o \$(CPPFLAGS) -o SelectionTool

main_selection.o: main_selection.cpp
	gcc -c main_selection.cpp

selection_tool.o: selection_tool.cc
	gcc -c selection_tool.cc

EOF_MAKE
  if [ $with_operation -ne 0 ];then
    # If OperationTool is also wanted
    cat >> Makefile << EOF_MAKE
OperationTool: main_operation.o operation_tool.o common_tools.o configuration.o
	gcc main_operation.o operation_tool.o common_tools.o configuration.o \$(CPPFLAGS) -o OperationTool

main_operation.o: main_operation.cpp
	gcc -c main_operation.cpp

operation_tool.o: operation_tool.cc
	gcc -c operation_tool.cc
EOF_MAKE
  fi
  if [ $need_to_install -eq 1 ];then
    cat >> Makefile << EOF_MAKE
.PHONY: install
prefix = '${prefix}'
install: all
	cp SelectionTool \$(prefix)/
	cp OperationTool \$(prefix)/

EOF_MAKE
  fi
  # For cleaning
  echo ".PHONY: clean" >> Makefile
  echo 'clean:' >> Makefile
  if [ $with_operation -ne 0 ];then
    echo -e "\trm -f OperationTool main_operation.o operation_tool.o" >> Makefile
  fi
  cat >> Makefile << EOF_MAKE
	rm -f SelectionTool main_selection.o selection_tool.o
	rm -f common_tools.o
EOF_MAKE
  if [ "$prefix" != `pwd` ];then
    echo -e "\trm -f \$(prefix)/SelectionTool \$(prefix)/OperationTool" >> Makefile
  fi
  logmsg 'Configuration done.'
  # This is the terminal guide
  cat << EOF_MAKE
  Next, please run in the current folder

    make

  to generate ${the_tools}.
EOF_MAKE
  if [ "${prefix}" != `pwd` ];then
    cat << EOF_MAKE
  And run (in the current folder)

    make install

  to install ${the_tools} in the target folder ${prefix}.
EOF_MAKE
  fi
  cat << EOF_MAKE
  To uninstall ${the_tools}, run in this folder
    make clean
EOF_MAKE
else
  # If compiling_tool is neither 'scons' nor 'make':
  errormsg "Unrecognized compiling tool |${compiling_tool}|..."
  exit 2
fi

# If installation prefix is not in PATH:
if [ `echo $PATH | grep "${prefix}" | wc -l` -eq 0 ];then
  echo "Don't forget to put ${prefix} into the environment :)"
fi
